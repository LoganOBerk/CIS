#include <iostream>

using namespace std;

int main() {

	//UML
	//
	//use case is summary of scenarios for a single task or goal
	//actor is who or what intitiates the events involved in the task
	//
	//when diagraming actors are stick figures use cases are ovals 
	//actors dont directly act with another actor but can be related
	//
	//associations are modeled as lines connecting 
	//
	//can draw rectangles around the use cases called system boundary box
	//the boxes can represent different time slots when it will be completed
	//
	//place primary actors in top left corner of the diagram
	//draw actors to the outside of the use case diagram
	//name actors with singular buisness relevant nouns
	//associate each actor with one or more use cases
	//use <<system>> to indicate system actors
	//actors dont interact with one another
	//introduce an actor called time to initiate scheduled events
	//
	//FOR EXAM
	//KNOW BASIC UML DIAGRAM ONLY
	//
	//
	//
	//
	//
	//ALGORITHM ANALYSIS
	//
	//a problem contains parameters its represents a class of problems
	//each specific assignment of values to the parameters is called an instance of the problem
	//
	//an algorithm is a step by step procedure to follow to solve a problem
	//write it like a recipe
	// 
	//Binary Search
	//	search a sorted array by repeatedly dividing the search interval in half
	//	check middle value to see what half to evaluate then keep going till you find number
	//
	//Determining efficiency
	//	DO NOT use number of CPU cycles
	//	DO NOT count every instruction executed
	//	we want a measure that is independant of the computer, programming language, programmer,
	//	and all of the complex details of the algorithm
	// 
	//In general
	//	running time of algorithm increases with size of input
	//	total running time is roughly proportional to how many times some basic operation is done
	//
	//find number of operations which cost the most
	//	multiplication/division
	//	
	//T(n) time complexity
	//W(n) worst case complexity
	//A(n) average case time complexity number of times the algorithm will ever do basic operations
	//B(n) best case time complexity analysis
	//
	//example complexity functions
	//f(n)
	//f(n^2)
	//f(lgn)
	//
	//linear time is faster than quadractic time
	//common complexities
	//O(lgn), O(n), 
	//Same big O notation can have higher or lower speeds based on specific scenarios
	//
	//Most often used is worst case
	//Most useful is average case
	//
	//Recursion
	//	a recursive function calls itself
	//	dont write recursive solutions unless you dont care about the time
	//	

	return 0;
}